package generation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

public class MazeBuilderEller extends MazeBuilder implements Runnable{
	
	//Private Variables
	private int[][] mazeSets;
	private int currentRow = 0; // tracks current row of maze
	private int currentCol = 0; // tracks current column of maze
	private int numSets = 1; //keeps track of what numbers have been used to indicate sets
	private HashMap<Integer, ArrayList<Integer>> hashmap;
	
	/**
	 * Constructor for a Maze generation using Eller's algorithm
	 */
	public MazeBuilderEller() {
		//call the super constructor
		super();
		System.out.println("MazeBuilderEller uses Eller's algorithm to generate maze.");
	}
	
	/**
	 * Constructor for Maze generated by Eller's algorithm with option 
	 * to make the maze deterministic or not
	 * @param deterministic, a boolean of whether the maze should be random or deterministic
	 */
	public MazeBuilderEller(boolean deterministic) {
		//call super constructor
		super(deterministic);
		System.out.println("MazeBuilderEller uses Eller's algorithm to generate maze.");
	}
	
	
	/**
	 * Generates pathways throughout the maze using Eller's algorithm
	 */
	@Override
	protected void generatePathways() {
		//hold sets in a 2-d array
		mazeSets = new int[width][height];
		boolean shouldJoin;
		//create sets for the first row
		for(int i = 0; i < width; i++) {
			mazeSets[i][0] = numSets;
			numSets++;
		}
		for(int i = 0; i < width - 1; i++) { //move across first row
			currentCol = i;
			shouldJoin = shouldJoinSets(); //random decision
			if(shouldJoin)
				joinSets();
		}
		makeVerticalConnections(); //randomly decides when vertical merges should be made
		
		//Every row after the first row
		for(int i = 1; i < height; i++) { //iterate through rows
			currentRow = i;
			generateRow(); // populate next row with sets
			for(int c = 0; c < width - 1; c++) { //iterate across row
				currentCol = c;
				shouldJoin = shouldJoinSets();//make random decision to join them
				if(shouldJoin)
					joinSets();
			}
			//randomly create vertical connections in each row except the last
			if(currentRow < height - 1)
				makeVerticalConnections(); //makes connections
			
		} 
		
		//If not all sets are merged by the end, do so in the final row
		boolean allJoined = true;
		for(int i = 0; i < width; i++) {
			if(mazeSets[0][height - 1] != mazeSets[i][height - 1]) {
				allJoined = false;
				break;
			}
		}
		if(!allJoined)
			joinLastRow();
	}
	
	/**
	 * randomly creates vertical connections to the next row, 
	 * but ensures each set has at least one representative in the next row
	 */
	protected void makeVerticalConnections() {
		ArrayList<Integer> value;
		Wallboard wallboard;
		
		//copy row into local array
		int[] copyOfRow = new int[width];
		for(int i = 0; i < width; i++)
			copyOfRow[i] = mazeSets[i][currentRow];
		
		//put all different sets into a Hash Map
		HashMap<Integer, ArrayList<Integer>> hashMap = new HashMap<Integer, ArrayList<Integer>>();
		for(int i = 0; i < copyOfRow.length; i++) {
			Integer key = copyOfRow[i];
			if(!hashMap.keySet().contains(key)) {
				 value = new ArrayList<Integer>();
				 hashMap.put(key, value);
			}
			hashMap.get(key).add(i); //adds a position of the value to the HashMap
		}
		
		//make sure each set gets at least one connection
		Integer[] setOfKeys = hashMap.keySet().toArray(new Integer[0]);
		for(int i = 0; i < setOfKeys.length;i++) {
			int currentSet = setOfKeys[i];
			int numEntries = hashMap.get(currentSet).size();
			int numSetConnections = 0;
			int random;
			
			for(int j = 0; j < numEntries; j++) {
				
			// random decision to make connection
				//forced to make connection if it is the final chance
				wallboard = new Wallboard(hashMap.get(currentSet).get(j), currentRow + 1, CardinalDirection.North);
				if(j == numEntries - 1 && numSetConnections == 0)
					random = 0;
				//check if room is present
				else if(floorplan.isPartOfBorder(wallboard)) {
					random = 1; //not going to connect downward
				}
				else
					random = (int)(Math.random() + 0.2);
					
				//make connection
				if(random == 0) {
					wallboard = new Wallboard(hashMap.get(currentSet).get(j), currentRow + 1, CardinalDirection.North);
					floorplan.deleteWallboard(wallboard);
					//make change to field
					mazeSets[hashMap.get(currentSet).get(j)][currentRow + 1] = mazeSets[hashMap.get(currentSet).get(j)][currentRow];
					numSetConnections++;
				}
			}
		}
	}
	
	/**
	 * private method that joins different sets during the creation of the maze and
	 * is used in the generatePathways() methods
	 */
	protected void joinSets() {
		//make it so both belong to the same set
		mazeSets[currentCol + 1][currentRow] = mazeSets[currentCol][currentRow];
		
		//knock down wall between them
		Wallboard wallboard = new Wallboard(currentCol, currentRow, CardinalDirection.East);
		floorplan.deleteWallboard(wallboard);
		
		//iterate through matrix
		for(int i = 0; i < currentRow - 1; i++) {
			for(int j = 0; j < width; j++) {
				// convert necessary sets to the now "dominant" set, in turn joining them together
				if(mazeSets[j][i] == mazeSets[currentCol + 1][currentRow]) {
					mazeSets[j][i] = mazeSets[currentCol][currentRow]; //join sets by converting to "dominant" set
				}
			}
		}
	}
	
	/**
	 * Breaks down all the walls in the last row and makes every cell belong to the same set
	 * only called if all the cells are not connected by the end
	 */
	protected void joinLastRow() {
		//breakdown all the walls in the last row
		for(int i = 0; i < width - 1; i++) {
			Wallboard wallboard = new Wallboard(i, height - 1, CardinalDirection.East);
			floorplan.deleteWallboard(wallboard);
		}
		//set every cell to the same set
		for(int i = 0; i < width; i++)
			for(int j = 0; j < height; j++)
				mazeSets[i][j] = 1; // arbitrary number to represent they are all in the same set
	}
	
	/**
	 * makes sure that every cell in the next row belongs to a set, 
	 * whether it be a new one or if it already has one
	 */
	protected void generateRow() {
		//if the cell doesn't have a set, give it a new one	
		for(int i = 0; i < mazeSets.length; i++) { // iterate over row
			if(mazeSets[i][currentRow]  == 0) {
				mazeSets[i][currentRow] = numSets;
				numSets++;
			}
		}	
	}
	
	/**
	 * randomly makes a decisions if two sets should be joined together or not
	 * @return true if the sets should be joined, false if not
	 */
	protected boolean shouldJoinSets() {
		//if sets are equal, no need to 
		if(mazeSets[currentCol][currentRow] == mazeSets[currentCol + 1][currentRow])
			return false;
		
		//check if part of border for rooms is between them
		Wallboard wallboard = new Wallboard(currentCol, currentRow, CardinalDirection.East);
		if(floorplan.isPartOfBorder(wallboard))
			return false;
		
		// decide randomly 
		int random = (int)(Math.random() + 0.5); //decide if sets should join
		if(random == 0)
			return true;
		return false; 
	}
	
	
	
	
	
	
///////////////////////////////////////////////////////////////////////////////////////	
/////////////////////////METHODS THAT MAY HELP TESTING/////////////////////////////////	
///////////////////////////////////////////////////////////////////////////////////////	
	
	
	
	
	
	/**
	 * returns the different sets in the maze, convenient for testing purposes
	 */
	public int[][] getMazeSets() {
		return mazeSets;
	}
	
	/**
	 * Returns the hashing created by generatePathways(), 
	 * solely for testing purposes
	 */
	public HashMap<Integer, ArrayList<Integer>> getHashMap(){
		return hashmap;
	}
	
	/**
	 * Allows the user to set the current row
	 * @param val value, what the row should be set to
	 */
	public void setRow(int val) {
		currentRow = val;
	}
	
	/**
	 * Allows the user to set the current column
	 * @param val value, what the column should be set to
	 */
	public void setCol(int val) {
		currentCol = val;
	}
	
	/**
	 * allows the user to change the mazeSet values, only for testing
	 * @param r row, the desired row
	 * @param c column, the desired column
	 * @param val value, what the value will be changed to
	 */
	public void setMazeSets(int c, int r, int val) {
		if(c < mazeSets.length && r < mazeSets[0].length)
			mazeSets[c][r] = val;
	}
}
